# CasualMemoryAgent - 统一图记忆系统设计

## 核心洞察

**Note（笔记）和 Event（事件）是同一物理结构（图节点）在不同语义维度上的投影。**

- 事件图构成**流程图**（Process Graph）：Agent 顺着走，完成任务
- 笔记图构成**知识网络**（Knowledge Graph）：Agent 顺着走，理解上下文

二者统一为一个有向图 G = (V, E)，区别仅在于边的语义类型。

---

## 1. 统一数据模型

### 1.1 节点基类 (GraphNode)

```python
from datetime import datetime
from enum import Enum
from typing import Optional
from pydantic import BaseModel

class NodeType(str, Enum):
    EVENT = "event"
    NOTE = "note"

class GraphNode(BaseModel):
    id: str                          # 唯一标识符
    type: NodeType                   # 节点类型
    content: str                     # 核心内容（笔记正文 / 事件描述）
    created_at: datetime             # 创建时间
    updated_at: datetime             # 最后修改时间
    metadata: dict = {}              # 扩展字段
    embedding: Optional[list] = None # 向量嵌入（用于语义检索）
```

### 1.2 事件节点 (Event)

```python
class EventStatus(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    DONE = "done"
    ARCHIVED = "archived"

class Event(GraphNode):
    type: NodeType = NodeType.EVENT
    status: EventStatus = EventStatus.PENDING
    due_date: Optional[datetime] = None
    priority: int = 0                # 优先级
```

### 1.3 笔记节点 (Note)

```python
class Note(GraphNode):
    type: NodeType = NodeType.NOTE
    title: str = ""                  # 笔记标题
    tags: list[str] = []             # 标签
    source: Optional[str] = None     # 来源（文件路径、URL等）
```

---

## 2. 边类型系统 (Edge Semantics)

### 2.1 设计原则

**极简边类型 + 内容承载语义**

- 图结构只记录**关系的存在性和方向**
- 语义细节（支持/反驳/强弱等）由**节点内容本身**表达
- LLM Agent 读取内容时**自然理解**语义

### 2.2 四种核心边类型

```python
class EdgeType(str, Enum):
    DEPENDS_ON = "depends_on"   # 时序依赖
    PART_OF = "part_of"         # 层级包含
    REFERENCES = "references"   # 引用关联
    PRODUCES = "produces"       # 因果产出

class Edge(BaseModel):
    source_id: str
    target_id: str
    edge_type: EdgeType
    created_at: datetime
```

### 2.3 完整语义矩阵

| source | target | edge_type | 含义 | 拓扑约束 |
|--------|--------|-----------|------|----------|
| Event | Event | `DEPENDS_ON` | A 依赖 B（B 完成后才能做 A） | DAG，禁止环 |
| Event | Event | `PART_OF` | A 是 B 的子任务 | 树形结构 |
| Note | Note | `REFERENCES` | A 引用 B | 允许环 |
| Event | Note | `REFERENCES` | 任务参考笔记（上下文输入） | 无限制 |
| Note | Event | `REFERENCES` | 笔记提及/跟踪任务 | 无限制 |
| Event | Note | `PRODUCES` | 任务产出笔记（执行结果） | 无限制 |
| Note | Event | `PRODUCES` | 笔记触发任务（知识转行动） | 无限制 |

### 2.4 层级分工

| 层级 | 负责内容 | 示例 |
|------|----------|------|
| **图结构** | 边的存在性、方向、节点类型 | A → B (REFERENCES) |
| **节点内容** | 语义细节 | "这与 [[B]] 的观点矛盾..." |
| **LLM Agent** | 读取内容，理解语义 | 识别出矛盾关系 |

---

## 3. 图的拓扑性质

### 3.1 事件子图 (Event Subgraph)

- **结构**: 有向无环图 (DAG)
- **约束**: `DEPENDS_ON` 边不允许循环依赖
- **时间性**: 边隐含时间先后顺序
- **遍历模式**: 拓扑排序 → 依次执行

### 3.2 笔记子图 (Note Subgraph)

- **结构**: 有向图（可含环）
- **约束**: 无（环代表知识密度）
- **时间性**: 弱时间性，旧可引用新
- **遍历模式**: 广度优先 / PageRank 式权重遍历

### 3.3 跨类型边 (Cross-Type Edges)

- **REFERENCES**: 双向引用（Event ↔ Note）
- **PRODUCES**: 因果链（Event 产出 Note / Note 触发 Event）
- **闭环**: Event 产出 Note → Note 触发新 Event → 形成工作流历史

---

## 4. Agent 遍历策略

### 4.1 执行任务时 (Task Execution)

```python
def execute_task(event_id: str):
    event = graph.get_node(event_id)

    # 1. 检查前置依赖
    blockers = graph.get_predecessors(event_id, edge_type="DEPENDS_ON")
    if any(b.status != "DONE" for b in blockers):
        return "Blocked by dependencies"

    # 2. 收集上下文（跨类型遍历）
    context_notes = graph.get_successors(event_id, edge_type="REFERENCES")

    # 3. 展开子任务
    subtasks = graph.get_predecessors(event_id, edge_type="PART_OF")

    # 4. 构建执行 Prompt
    return build_prompt(event, context_notes, subtasks)
```

### 4.2 理解知识时 (Knowledge Retrieval)

```python
def explore_topic(note_id: str, depth: int = 2):
    note = graph.get_node(note_id)

    # 1. 获取引用的笔记
    refs = graph.get_successors(note_id, edge_type="REFERENCES")

    # 2. 查看关联的活跃任务
    related_events = graph.get_successors(note_id, edge_type="REFERENCES")
    active_events = [e for e in related_events
                     if e.type == "event" and e.status != "ARCHIVED"]

    # 3. 查看由此笔记触发的任务
    triggered = graph.get_successors(note_id, edge_type="PRODUCES")

    # 4. 递归展开（控制深度）
    if depth > 0:
        for ref in refs:
            explore_topic(ref.id, depth - 1)
```

### 4.3 统一检索接口

```python
def resolve_context(node_id: str) -> Context:
    """无论节点类型，统一获取相关信息"""
    node = graph.get_node(node_id)

    return Context(
        main=node,
        dependencies=graph.get_neighbors(node_id, edge_type="DEPENDS_ON"),
        subtasks=graph.get_neighbors(node_id, edge_type="PART_OF"),
        references=graph.get_neighbors(node_id, edge_type="REFERENCES"),
        produces=graph.get_neighbors(node_id, edge_type="PRODUCES"),
    )
```

---

## 5. 工程实现要点

### 5.1 存储方案

**推荐**: 双层存储

| 层级 | 存储 | 用途 |
|------|------|------|
| 图结构层 | SQLite / Neo4j | 节点关系、边、快速遍历 |
| 向量层 | LanceDB / Chroma | 语义检索、相似度搜索 |

```sql
-- 节点表
CREATE TABLE nodes (
    id TEXT PRIMARY KEY,
    type TEXT NOT NULL,  -- 'event' | 'note'
    content TEXT,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    metadata JSON,
    status TEXT  -- 仅 event 使用
);

-- 边表（极简设计）
CREATE TABLE edges (
    source_id TEXT,
    target_id TEXT,
    edge_type TEXT NOT NULL,  -- 只有 4 种类型
    created_at TIMESTAMP,
    PRIMARY KEY (source_id, target_id, edge_type)
);
```

### 5.2 边类型校验

```python
def add_edge(source_id: str, target_id: str, edge_type: EdgeType):
    source = graph.get_node(source_id)
    target = graph.get_node(target_id)

    # 校验边类型合法性
    valid_edges = {
        ("event", "event"): ["DEPENDS_ON", "PART_OF"],
        ("note", "note"): ["REFERENCES"],
        ("event", "note"): ["REFERENCES", "PRODUCES"],
        ("note", "event"): ["REFERENCES", "PRODUCES"],
    }

    key = (source.type, target.type)
    if edge_type not in valid_edges.get(key, []):
        raise ValueError(f"Invalid edge type {edge_type} for {key}")

    # Event 依赖边需要环检测
    if edge_type == "DEPENDS_ON":
        if graph.has_path(target_id, source_id, edge_types=["DEPENDS_ON"]):
            raise CyclicDependencyError("Adding this edge would create a cycle")

    graph.add_edge(source_id, target_id, edge_type)
```

### 5.3 避免混乱的策略

#### 策略一：生命周期隔离

- 默认视图隐藏 `status = ARCHIVED` 的 Event 链接
- Note 页面只显示活跃任务关联

#### 策略二：锚点分离

- 关联关系存储在图数据库的边表中
- Note 的 Markdown 正文保持纯净，不污染链接
- 反向查询动态获取关联

---

## 6. 设计总结

```
┌─────────────────────────────────────────────────────────────┐
│                    Unified Memory Graph                     │
│                      (4 Edge Types)                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────┐    REFERENCES     ┌─────────────┐        │
│   │   Event A   │ ────────────────► │   Note X    │        │
│   │  (pending)  │                   │  (context)  │        │
│   └──────┬──────┘                   └──────┬──────┘        │
│          │ DEPENDS_ON                      │ REFERENCES    │
│          ▼                                 ▼               │
│   ┌─────────────┐    PRODUCES       ┌─────────────┐        │
│   │   Event B   │ ────────────────► │   Note Y    │        │
│   │   (done)    │                   │  (output)   │        │
│   └─────────────┘                   └──────┬──────┘        │
│                                            │               │
│                                    PRODUCES│               │
│                                            ▼               │
│                                     ┌─────────────┐        │
│                                     │   Event C   │        │
│                                     │ (triggered) │        │
│                                     └─────────────┘        │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │ DEPENDS_ON : Event → Event  (时序依赖，DAG)         │  │
│   │ PART_OF    : Event → Event  (子任务层级)            │  │
│   │ REFERENCES : Any → Any      (引用关联)              │  │
│   │ PRODUCES   : Event ↔ Note   (因果产出)              │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 核心优势

1. **极简抽象**: 4 种边类型覆盖所有场景
2. **语义分离**: 图存关系，内容存语义，LLM 理解细节
3. **统一遍历**: 一套 API 处理所有节点和边
4. **闭环形成**: Event ↔ Note 双向链接，完整工作流历史

### 下一步

1. 实现 `MemoryGraph` 核心类
2. 设计 Agent 的 Tool 接口（`add_note`, `create_event`, `link_nodes`）
3. 构建检索层（语义搜索 + 图遍历融合）
